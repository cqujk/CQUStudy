编译器提供的库函数
当应用程序进入内核后，自己就下 CPU 了，它的上下文环境已经被保存到自己的 0 特权级栈中了，此时在 CPU 上运行的程序是内核程序
应用程序处于特权级 3，操作系统内核处于特权级 0
当用户程序欲访问系统资源时（无论是硬件，还是内核数据结构），它需要进行系统调用。这样 CPU 便进入了内核态，也称管态
在直接以绝对物理地址访问内存的 CPU 上运行程序，该程序中指令的地址也必须得是绝对物理地址
	若加载程序运行，不管其是内核程序，还是用户程序，程序中的地址若都是绝对物理地址，那该程序必须放在内存中固定的地方，于是，两个编译出来地址相同的用户程序还真没法同时运行，只能运行一个

# 07 

CPU 采用“段基址+段内偏移地址”的形式访问内存，就需要专门提供段基址寄存器，这些是 cs、ds、 es 等
	程序中需要用到哪块内存，只要先加载合适的段到段基址寄存器中，再给出相对于该段基址的偏移地址便可，CPU 中的地址单元会将这两个地址相加后的结果用于内存访问，送上地址总线
把整个段平移到任何位置后，段内的地址相对于段基址是不变的，无论段基址是多少，只要给出段内偏移地址，CPU 就能访问到正确的指令

#？ 
> 偏移地址也要存入寄存器，

[[操作系统真象还原.pdf#page=17&selection=106,2,106,12|操作系统真象还原, 页面 17]]

# 8
即将当前 eip 中的地址加上当前指令机器码的大小便是内存中下一条指令的起始地址
为了让程序内指令接连不断地执行，要把指令全部排在一起，形成一片连续的指令区域，这就是代码段

16 进制，需要 4 位二进制来表示，那么 8 ED 8，就需要 4 * 4=16位二进制，即 2 字节
	*即每两位 16 进制就是 1 个字节*

将数据和代码分开的好处有三点
	为数据赋予不同的属性，
		- 例如数据本身是需要修改的，所以数据就需要有可写的属性，不让数据段可写，那程序根本就无法执行啦
		- 程序中的代码是不能被更改的，这样就要求代码段具备只读的属性
	提高 CPU 内部缓存的命中率
		缓存起作用的原因是程序的局部性原理。在 CPU 内部也有缓存机制，将程序中的指令和数据分离，这有利于增强程序的局部性


### Q:***数据段或代码段的属性是谁给添加上的呢，是谁又去根据属性保护程序的呢，是程序员吗？是编译器吗？是操作系统吗？还是 CPU 一级的硬件支持？***
先看 CPU 为我们提供了哪些原生的支持。在保护模式下，有这样一个数据结构，它叫全局描述符表（Global Descriptor Table，GDT），这个表中的每一项称为段描述符
	什么是描述符？描述符就是描述某种数据的数据结构，是元信息，属于数据的数据
*在段描述符中有段的属性位*，在以后的章节中可以看到，其实是有 2 个，*一个是 S 字段，占 1 bit 大小，另外一个是占 4 bit 大小的 TYPE 字段，这两个字段配合在一起使用就能组合出各种属性*，如只读、向下扩展、只执行等
操作系统在让 CPU 进入保护模式之前，首先要准备好 GDT，也就是要设置好 GDT 的相关项，填写好段描述符
*段描述符填写成什么样，段具备什么样的属性*，这**完全取决于操作系统**了，在这里大家只要知道，*段描述符中的 S 字段和 TYPE 字段负责该段的属性，也就是该属性与安全相关*

编译器负责挑选出数据具备的属性，从而根据属性将程序片段分类
	比如，划分出了只读属性的代码段和可写属性的数据段
		只负责划分出来，但不负责赋予其属性。对于代码段，编译器所做的只是将代码归类到一起而已，也就是将程序中的有关代码的多个 section 合并成一个大的 segment（这就是我们所说的代码段），它并没有为代码段添加额外的信息
操作系统通过设置 GDT 全局描述符表来构建段描述符，在段描述符中指定段的位置、大小及属性（包括 S 字段和 TYPE 字段）
	操作系统认为代码应该是只读的，所以给用来指向代码段的那个段描述符设置了只读的属性，*这才是真正给段添加属性的地方*
CPU 中的段寄存器提前被操作系统赋予相应的选择子（后面章节会讲什么是选择子，暂时将其理解为相当于段基址），*从而确定了指向的段*. 在执行指令时，*会根据该段的属性来判断指令的行为，若有返回则发出异常*。

# 9
无论在实模式或是保护模式下，段内偏移地址又称为有效地址，也称为逻辑地址，这是程序员可见的地址
线性地址或称为虚拟地址，这都不是真实的内存地址。它们都用来描述程序或任务的地址空间。由于分页功能是需要在保护模式下开启的，32 位系统保护模式下的寻址空间是 4 GB，所以虚拟地址或线性地址就是 0～4 GB 的范围
# 10
假设在实模式下, 一个段最大为 64 KB，其大小由段内偏移地址寻址范围决定, 也就是 2 的 16 次方
假设段 A 的段基址是从 0 xC 00 开始，段 B 的段基址是从 0 xC 02 开始，在 16 位宽度的寻址范围内，这两个段都能访问到 0 xC 05 这块内存, 像是重叠在一起了，这就是段重叠了
# 11
平坦模型是相对于多段模型来说的，所以说平坦模型指的就是一个段
在实模式下，访问超过 64 KB 的内存，需要重新指定不同的段基址，通过这种迂回变通的方式才能达到目的
保护模式下，由于其是 32 位的，寻址范围便能够达到 4 GB，段内偏移地址也是地址，所以也是 32 位
在 32 位环境下用一个段就能够访问到硬件所支持的所有内存
也就是说，段的大小可以是地址总线能够到达的范围
# 12
> CPU 内部的段寄存器（Segment reg）如下

[[操作系统真象还原.pdf#page=24&selection=212,0,216,3|操作系统真象还原, 页面 24]]

32 位 CPU 有两种不同的工作模式：实模式(16位)和保护模式（32位）
每种模式下，段寄存器中值的意义是不同的，但不管其为何值，*在段寄存器中所表达的都是指向的段在哪里*
在实模式下，CS、DS、ES、SS 中的值为*段基址，是具体的物理地址*，内存单元的逻辑地址仍为 “段基值：段内偏移量”的形式
在保护模式下，装入段寄存器的不再是段地址，而是“段选择子”（Selector），当然，选择子也是数值，其依然为 16 位宽度
# 13
软件中的工程是指开发一套软件所需要的全部文件，包括配置环境
全部文件包含实际代码和环境配置两部分。
	- 实际代码部分，除了自己写的代码文件之外，一般都要包含其他同事写的头文件，若是与他方合作，还要包含第三方头文件
	- 环境配置部分，一般是配置一些模板、库文件目录，具体还要根据所用的实际框架来配置，包含一些服务器的地址，端口之类也都在配置文件中
# 14
Linux 下的可执行程序格式是 elf，也就是 “Executable and Linking Format”
	用 readelf 命令可以查看 elf 文件头
		里面有节（section） 信息、段（segment）信息、程序入口（entry_point）、哪个段由哪些节组成等信息
而 Windows 下的可执行程序是 PE 格式（portable executable，可移植的可执行文件

系统 API 不同
Linux 中的 API 称为系统调用，是通过 int 0 x 80 这个软中断实现的。而 Windows 中的 API 是存放在动态链接库文件中的，也就是 Windows 开发人员常说的 DLL，即 Dynamic Link Library 的缩写

LL 是一个库，里面包含代码和数据，可供用户程序调用，DLL 不是可执行文件，不能够单独运行
Linux 中的可执行程序获得系统资源的方法和 Windows 不一样，所以显然是不能在 Windows 中运行的
# 15
栈从高地址往低地址发展，堆是从低地址往高地址发展
# 17
编译器用什么语言写是无所谓的，关键是能编译出指令就行了
要发明一种语言，关键是得写出与之配套的编译器，这两者是同时出来的
# 18
解释型语言，也称为脚本语言，如 JavaScript、Python、Perl、PHP、Shell 脚本等。*它们本身是文本文件，是某个应用程序的输入，这个应用程序是脚本解释器。*
由于只是文本，这些脚本中的代码在脚本解释器看来和字符串无异。也就是说，*脚本中的代码从来没真正上过 CPU 去执行*，CPU 的 cs：ip 寄存器从来没指向过它们，在 CPU 眼里只看得到脚本解释器，而这些脚本中的代码，CPU 从来就不知道有它们的存在
本质上是*脚本解释器在时时分析这个脚本，动态根据关键字和语法来做出相应的行为。因此脚本中若出现错误，先前正确的部分也会被正常执行，* 这和编译型程序有很大区别
在执行一个 PHP 脚本时，其实就是*启动一个 C 语言编写出来的解释器*而已，这个解释器就是一个进程，和一般的进程是没有区别的，只是*这个进程的输入则是这个 php 脚本，在 php 解释器中，这个脚本就是个长一些的字符串*，根本不是什么指令代码之类。只是这种解释器了解这种语法，按照语法规则来输出罢了。
```php
<?php
	echo "abcd"
?>
```
PHP 解释器分析文本文件 a.php 时，发现里面的 echo 关键字，*将其后面的参数获取后就调用 C 语言中提供的输出函数*，如 printf（（echo 的参数））
PHP 解释器对于 PHP 脚本，就相当于浏览器对于 JavaScript 一样
# 19
*内存是以字节为单位读写的，其最小的读写单位就是字节*
可是 1 字节要能够表示的范围只有 0～255（先只考虑无符号数），超过这个范围的数，只好用多个字节连在一起来表示
## 这么多个字节该以怎样的顺序排放呢
一个超过 255 的数字必然要占用 2 个字节以上，这两个字节，在物理内存中，哪个在前？哪个在后？拿 0 x 1234 举例，数值中的高位 12 是放在内存的高地址处，还是低地址处？

于是就产生了这两种相反的排列顺序
- 小端字节序是数值的低字节放在内存的低地址处，数值的高字节放在内存的高地址
- 大端字节序是数值的低字节放在内存的高地址处，数值的高字节放在内存的低地址。

两种字节序的优势。
- 小端：因为低位在低字节，强制转换数据型时不需要再调整字节了
	- 在做强制数据类型转换时，如果转换是由低精度转向高精度，这数值本身没什么变化，如 short 是 2 字节，将其转换为 4 字节的 int 类型，无非是由 0 x 1234 变成了 0 x 00001234，数值上是不变的，只是存储形式上变了
	- 如果转换是高精度转向低精度，也就是多个字节的数值要减少一些存储字节，这必然是要丢弃一部分数值
- 大端：有符号数，其字节最高位不仅表示数值本身，还起到了符号的作用。符号位固定为第一字节，也就是最高位占据最低地址，符号直接可以取出来，容易判断正负

编译器的转换原则是强制转换到低精度类型，丢弃数值的高字节位，只保留数值的低字节
对于大端的优势，就硬件而言，就是符号位的判断变得方便了。最高位在最低地址，也就是直接就可以取到了，不用再跨越几个字节，减少了时钟周期
	对于人类来说，还是大端看上去顺眼，毕竟咱们存储 0 x 12345678 到内存时，它在内存中的存储顺序也是 0 x 12345678，而不是 0 x 78563412，这样看上去才直观

字节序不仅是在 CPU 访问内存中的概念，而且也包括在文件存储和网络传输中。Bmp 格式的图片就属于小端字节序，而 jpeg 格式的图片则为大端字节序

网络字节序就是大端字节序，所以在 x 86 架构上的程序在发送网络数据时，要转换字节顺序
# 20
如果事件来自于 CPU 内部就称为异常，即 Exception
	该事件由外部设备发出并通知了 CPU，这个事件就称为异常

BIOS 和 DOS 都是存在于实模式下的程序，由它们建立的中断调用都是建立在中断向量表（Interrupt Vector Table，IVT）中的。它们都是通过软中断指令 int 中断号来调用的
中断向量表中的每个中断向量大小是 4 字节。这 4 字节描述了一个中断处理例程（程序）的段基址和段内偏移地址
	因为中断向量表的长度为 1024 字节，故该表最多容纳 256 个中断向量处理程序
计算机启动之初，中断向量表中的中断例程是由 BIOS 建立的，它从物理内存地址 0 x 0000 处初始化并在中断向量表中添加各种处理例程

访问外设有两种方式
	内存映射：通过地址总线将外设自己的内存映射到某个内存区域（并不是映射到主板上插的内存条中）
	端口操作：外设都有自己的控制器，控制器上有寄存器，这些寄存器就是所谓的端口，通过 in/out 指令读写端口来访问硬件的内存

# 21
预处理阶段是预处理器将高级语言中的宏展开，去掉代码注释，为调试器添加行号等
编译阶段是将预处理后的高级语言进行词法分析、语法分析、语义分析、优化，最后生成汇编代码
汇编阶段是将汇编代码编译成目标文件，也就是转换成了目标机器平台上的机器指令
链接阶段是将目标文件连接成可执行文件

操作系统在加载程序时，不需要对逐个节进行加载，只要给出相同权限的节的集合就行了，例如把所有只读可执行的节（如代码节. Text 和初始化代码节. Init）归并到一块，所有可读写的节（如数据节. Data 和未初始化节. Bss）归并到一块，这样操作系统就能为它们分配不同的段选择子，从而指向不同段描述符，实现不同的访问权限了。

链接器将目标文件中属性相同的节合并成一个大的 section 集合，此集合便称为 segment，也就是段，此段便是我们平时所说的可执行程序内存空间中的代码段和数据段
# 23
，一个硬盘上可以有很多分区，每个分区的格式又可以不同。就拿 Linux 来说，既能识别 ext 3，又能识别 ext 4
文件系统也有自己的魔数
各分区都有超级块，一般位于本分区的第 2 个扇区，比如若各分区的扇区以 0 开始索引，其第 1 个扇区便是超级块的起始扇区。超级块里面记录了此分区的信息，其中就有文件系统的魔数，一种文件系统对应一个魔数，比对此值便知道文件系统类型了
# 28
计算机在接电之后运行的是基本输入输出系统 BIOS, 必须采取*控制权接力的方式*，一步步地让处理器执行更为复杂强大的指令，最终把处理器的使用权交给操作系统
为了方便 BIOS 找到 MBR，MBR 必须在固定的位置等待，因此 MBR 位于整个硬盘最开始的扇区
MBR 是主引导记录，Master 或 Main Boot Record，它存在于整个硬盘最开始的那个扇区，即 0 盘 0 道 1 扇区，这个扇区便称为 MBR 引导扇区