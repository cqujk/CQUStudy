# 互斥
信号量包括一个整型值和一个等待队列 queue，并且只能通过两个原语 wait (), signal ()操作来访问
信号量表示其类可用的共享资源数目

Wait ()操作意味着进程请求一个资源，所以资源数目减一
Signal ()意味着进程释放一个资源，s.value的值加一

如果信号量初始值为 1，表示仅允许一个进程访问临界区，此时信号量为互斥信号量

***这个信号量不是某个进程的信号量，而是系统资源的信号量***
*是进程通过 wait () 与 signal ()方法来对信号量做出修改，并依据信号量来进行仲裁*
# 同步
## 信号量与同步
当信号量为 0，表示所期望的消息尚未产生；
而信号量为非 0整数值时，表示所期望的消息已经存在了
### 使用 s 与 w操作实现进程同步
若信号量为 s
	意思是说对系统资源 s 的资源量
**调用 signal ()发送消息**
若某个进程需要向其它进程发送消息，可使用 signal (s) 原语
- 若调用之前，信号量为 0，则表示消息未产生，同时没有任何进程在等待该消息；调用之后，信号量大于 0，表示消息已经存在
- 若调用之前，信号量小于 0，则表示有进程因为等待该消息而被阻塞起来；此时调用完 signal (s) 后可以唤醒一个阻塞进程
**调用 wait (）检测消息**
尝试调用 wait (s)来检测自己所期望的消息是否已经到达
- 若调用前>0, 表示消息已经存在；调用后，检测到已存在，故可以继续执行
- 若前<0, 表示未产生；调用后，检测到未产生，此时必须等待
## 生产者/消费者问题
使用某一类资源的进程称为该资源的消费者，把释放同类资源的进程称为生产者

系统保证避免对缓冲区的重复操作，即任何时候只有一个主体可以访问缓冲区
	*通过设置 mutex信号量为 1来实现*
	在使用缓冲区前，应当 wait (mutex)；而退出缓冲区时，就要 signal (mutex);
	***所以这两个操作必须成对出现***
	*成对出现之后，就是相当于一个{}，包括其中的代码就是对某一资源的互斥访问或使用，相当于原语*
缓冲区满时，不会再放资源；空时，不会再用资源；
	设置两个信号量，用之前应当先判断是否有资源
		对于生产者而言，
			就是判断是否满了，但是是否满了不好判断，因为不能直接和资源量 n去进行比较，而且每次在生产的时候是用 wait()方法，是要让信号量减少的，(*即和 wait 的方法相反*)所以设定初始信号量为 n，每次 wait ()的时候就会使其减 1,直到为 0的时候就意味着加满了
		对于消费者而言,
			是判断是否还有剩余, 这个比较好判断,和 wait () 的方向一致,因为生产与消费和 wait 的方向不一样,所以消费者也要有一个信号量
		但是双方都不生产自己的信号量,自己的信号量是由对方生产, signal () 得到的
需注意,应当*先判断是否可操作的条件,再进入缓冲区*
否则,若先进入缓冲区 (即 wait (mutex)) 后,再判断条件,若发现不满足条件,那么就会一直等,但是要想满足条件,需要另一个进程对资源进行修改,但如果要进行修改,则必须占用缓冲区,而*此时已经被进程占用了,所以造成了死锁*
## 读者/写者问题
### 问题特性
- 任意多的读者进程同时读这个文件
- 一次只有一个写者进程可以写文件
- 如果一个写者进程正在写文件, 则禁止任何读者进程读文件
- 读者进程不排斥其它读者进程,而写者需要排斥自己以外的其它进程 
### $mutex$ 信号量
$mutex_{count}=1;mutex_{write}=1$
*$mutex=1$ 就相当于对资源上了一个互斥锁，如果某一时刻信号量为 1，则表示可以占用，不然则不能占用*

$mutex_{count}$ 的目的是为了保证对内存单元 readcount访问的互斥，就是说同一时间只能有一个读者对其做出修改，防止 readcount数量不对
而 $mutex_{write}$ 是为了实现读者与写者进程的互斥,**$mutex_{write}$ 相当于对文件的使用权**，由于写进程要排斥其它进程，所以一定要 $wait(mutex_{write})$, 这样才能在修改文件时没有其它文件同时在读写这个文件

### 过程
读进程一进来，先尝试占用 $mutex_{count}$，在其中使 $readcount++$，之后释放 $mutex_{count}$, 让其它读者可以对其进行修改，就是说不妨碍其它读者一起同时读，但是对统计读者数量的资源 $count$ 在修改时需要进行占用，防止出现意外
在读者读完后要修改 $count$，同样的流程

当某个读者进程进入临界区时，*如果发现是第一个读者进程，就调用 $wait(mutex_{write})$，判断 $mutex_{write}$ 是否为 1，即资源是否有占用*
	 如果 $mutex_{write}==0$ ，说明此时有写者进程在写文件，则该读者进程阻塞，等待接收与写者进程互斥的信号量
	 不然，则说明这个资源在此时即没有读进程也没有写进程
但是读进程在读的时候，是要和写进程互斥的，不能让写进程做出修改，所以第一个读者要对该资源上锁，所以要 $wait (mutex_{write})$
	*相当于干了两件事，第一件是判断资源是否被占用（上锁）；第二件就是若没有被占用时，则对该资源上锁*
	只有第一个或最后一个读者才需要对 $mutex_{write}$ 做出修改，中间的其它读进程都不必，因为此时该资源就已经被读进程所占用了，不必再上锁
读进程读完后，需要对 $count$ 做出修改，使其减 1，若是最后一个读者，那么就意味着所有读进程对资源的占用结束，应释放锁，即 $signal(mutex_{count})$

而写进程就很简单，只需要在占用资源时，进行 wait 上锁，写完后再 signal开锁即可

## 其它应用
### 独木桥
相当于读者/写者的变版，那个是读者有很多，写者只能有一个，现在相当于分为了两类，都承担了类似于读者的行为
因此需要 3 个信号量
1 个信号量用于对独木桥的互斥访问，2个分别用于左右桥的计数时的互斥操作
### 取物问题
一次只能装一个水果的意思就是盘子上只能有一个
所以应当有 3个信号量，锁，一个用于盘子的互斥使用，2个用于水果计数的操作
只有水果数量为 0 时，才能放水果
	为 1 时，才能拿水果
应当先判断取/拿条件，再尝试获得盘子的锁
	否则将造成死锁
![[Pasted image 20240920101436.png]]
*P 112,为什么只有父母进程才需要获取盘子的锁？*
假象一个场景，父亲先获取锁，然后放橘子，释放锁，之后母亲 [[Drawing 2024-09-20 10.00.13.excalidraw]]
*解释*
这里注意，父母进程中虽然占用了盘子的锁，但是并不像前几个问题一样，在自己的进程中就把锁给释放了
因为这个**上锁的，并不是对盘子的操作权，或者说是不只有盘子的操作权**，由于盘子上只有一种水果的限制，当苹果在盘子上时，橘子就不能再盘子上
即虽然父进程结束了，但由于橘子还没被儿子吃完，那么即使盘子的操作权是空的，母亲也不能占用，只有等待儿子把橘子吃了才行
所以这个锁上的，相当于是对吃和放两个进程上锁了，保证这两个进程能够衔接着执行，*只有当取进程结束了，拿进程中放的锁才会打开*

如果两个进程紧密相连，如父亲放，儿子才能取，且父亲放后，母亲与女儿都不能再操作的话，那么父亲与儿子这两个进程就可以共同占有一把锁
### 进程的前驱后继问题
就是化为拓扑排序，对结点之间的边构建信号量
那么依赖这条边，即被这条边指向的进程，即结点，需要 wait这条边的信号量；
当结点完成之后，就释放边信号，即 signal由该结点发出的边的信号
# 进程之间通信
分两种，控制信息传送和大批量数据传送
高级通信机制：共享内存方式、管道通信机制以及消息传递通信
## 共享内存
调用 shmget 来分配一个共享内存块，然后每个进程通过 shmat 绑定到共享内存块，*将进程的逻辑虚拟地址指向共享内存块中*
## 管道通信
连接一个读进程和一个写进程
提供输入的是发送进程

Fds[0]为读端、fds[1]为写端
Fork () 创建一个子进程
## 消息传递
接收进程使用 receive 原语，从自己的消息缓冲队列 mq 中取下一个消息 i

在 send 时，会使对应信箱上数量+1，判断 send 的条件，应当构造一个信号量初始为信箱大小 n, 进程结束时，应当让另一个信号量，即决定 receive 条件的信号量 full (初始为 0) 的值++
# 管程
## 概念
前后两次调用 wait () 而不释放，会陷入自死锁

管程，把分散在各进程中的临界区集中起来进行管理
其中函数为两种，外部函数（带有标识符 entry），内部函数（不带）

所有进程要访问临界资源，都必须经过管程，其每次只准许一个进程进入
里面有紧急队列，就是处理进程间互相唤醒时用的，比外部的等待队列优先级高

**管程的 wait 和 signal和之前的操作很不一样，甚至几乎无关**

*X.wait ()：如果紧急等待队列非空，则唤醒第一个等待者；否则释放管程的互斥权，本进程阻塞进入 x 变量的等待队列中。
X.signal (): 如果 x 非空，则什么都不做；否则唤醒第一个等待者，本进程的 PCB 进入紧急等待队列的尾部*
## 管程解决生产者-消费者
Put，生产者，如果满了，就调用管程的 wait，进入 notfull 的等待队列中；不然，就放入了，然后尝试唤醒消费者进程，通过 notempty. Signal () 实现
如果 notempty 当中有对象，就说明有消费者进程因为缓冲区空了而等待
Get, 空了进入 notempty 的等待队列；不然，取出，如果 notfull 当中有对象，说明有生产者进程因为缓冲区满了而等待；
#？ 感觉不是很懂
# Linux 内核同步机制
## 原子操作
Atomic_t，一个 24 位原子访问计数器
## Per-CPU
#？ 
## 自旋锁
## 内存屏障
单处理器下的乱序问题和多处理器下的内存同步问题
由于不同指令的条件，可能造成“顺序流入，乱序流出“
通过指令重排将存在依赖关系的两条指令拉开距离

如果是在某某设备驱动程序中，这俩变量可能对应到设备的地址端口和数据端口
需要使用屏障来抑制乱序，读、写、通用、优化

# 小结
进程存在两种关系：同步和互斥

如果等待时间较长，互斥体比自旋锁更合适，因为自旋锁会消耗 CPU资源