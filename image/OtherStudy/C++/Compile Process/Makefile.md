### Makefile编译过程
![[Pasted image 20240914003551.png]]

Makefile文件中的[命令](https://so.csdn.net/so/search?q=%E5%91%BD%E4%BB%A4&spm=1001.2101.3001.7020)有一定规范，一旦该文件编写好以后在Linux[命令行](https://so.csdn.net/so/search?q=%E5%91%BD%E4%BB%A4%E8%A1%8C&spm=1001.2101.3001.7020)中执行一条make命令即可自动编译整个工程
### 语法规则
```
目标 ... : 依赖 ...
	命令1
	命令2
	. . .

```
Makefile的核心规则，类似于一位厨师做菜，目标就是做好一道菜，那么所谓的依赖就是各种食材，各种厨具等等，然后需要厨师好的技术方法类似于命令，才能作出一道好菜。
同时这些依赖也有可能此时并不存在，需要现场制作，或者是由其他厨师做好，那么这个依赖就成为了其他规则的目标，该目标也会有他自己的依赖和命令。这样就形成了一层一层递归依赖组成了Makefile文件
Makefile并不会关心命令是如何执行的，仅仅只是会去执行所有定义的命令，和我们平时直接输入命令行是一样的效果

- **目标**即要生成的文件。如果目标文件的更新时间晚于**依赖**文件更新时间，则说明依赖文件没有改动，目标文件不需要重新编译。否则会进行重新编译并更新目标文件
	- 这个说的意思就是如果依赖文件没有变，那么目标文件就是最新的，就不需要重新编译，而如果依赖文件更新时间比目标文件晚，就说明目标文件不新了，需要重新编译
- 默认情况下Makefile的第一个目标为终极目标
- 依赖：即目标文件由哪些文件生成
- 命令：即通过执行命令由依赖文件生成目标文件。注意每条命令之前必须有一个**tab**
##### `all`
all：Makefile文件默认只生成第一个目标文件即完成编译，但是我们可以通过all 指定所需要生成的目标文件。例如下面的例子
```
all: target1 target2 target3
target1:
# 编译规则1
target2:
# 编译规则2
target3:
# 编译规则3

```

all被设置为第一个目标，并且target1、target2和target3被列为all的依赖。当你在命令行中运行make时，make命令会寻找并执行all目标规则，这将依次执行target1、target2和target3的编译规则。
因此，通过在Makefile中设置all作为默认目标规则，你可以简化构建过程，只需运行make命令即可执行整个编译过程，无需显式指定目标
### 变量

### 简单的Makefile实例
目录结构
![[Pasted image 20240914004356.png]]![[Pasted image 20240914004412.png]]
Makefile
目标前面的路径，意思是将目标生成到指定的目录下
```Cmake
../$(OBJS_DIR)/f1.o:f1.c                                                                                       
	@$(CC) -c $^ -o $@  
```

