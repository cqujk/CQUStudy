`impl Rectangle {}` 表示为 `Rectangle` 实现方法(`impl` 是实现 _implementation_ 的缩写)，这样的写法表明 `impl` 语句块中的一切都是跟 `Rectangle` 相关联的。

`self` 依然有所有权的概念：

- `self` 表示 `Rectangle` 的所有权转移到该方法中，这种形式用的较少
- `&self` 表示该方法对 `Rectangle` 的不可变借用
- `&mut self` 表示可变借用

因为 `T` 可以是任何类型，***但不是所有的类型都能进行比较***，因此上面的错误中，编译器建议我们给 `T` 添加一个类型限制:
使用 `std::cmp::PartialOrd` 特征（Trait）对 `T` 进行限制，特征在下一节会详细介绍，现在你只要理解，该特征的目的就是让**类型实现可比较的功能**
同样的，***不是所有 `T` 类型都能进行相加操作***，因此我们需要用 `std::ops::Add<Output = T>` 对 `T` 进行限制
- **提前声明**，跟泛型函数定义类似，首先我们在使用泛型参数之前必需要进行声明 `Point<T>`，接着就可以在结构体的字段类型中使用 `T` 来替代具体的类型
- - **x 和 y 是相同的类型**
当把 `1` 赋值给 `x` 时，变量 `p` 的 `T` 类型就被确定为整数类型，因此 `y` 也必须是整数类型，但是我们却给它赋予了浮点数，因此导致报错。
如果想让 `x` 和 `y` 既能类型相同，又能类型不同，就需要使用不同的泛型参数：

提到枚举类型，`Option` 永远是第一个应该被想起来的

如果函数正常运行，则最后返回一个 `Ok(T)`，`T` 是函数具体的返回值类型，如果函数异常运行，则返回一个 `Err(E)`，`E` 是错误类型

`Result<T, E>` 用于可恢复错误，`panic!` 用于不可恢复错误
在 Rust 中触发 `panic` 有两种方式：被动触发和主动调用
## [线程 `panic` 后，程序是否会终止？](https://course.rs/basic/result-error/panic.html#%E7%BA%BF%E7%A8%8B-panic-%E5%90%8E%E7%A8%8B%E5%BA%8F%E6%98%AF%E5%90%A6%E4%BC%9A%E7%BB%88%E6%AD%A2)
如果是 `main` 线程，则程序会终止，如果是其它子线程，该线程会终止，但是不会影响 `main` 线程。因此，尽量不要在 `main` 线程中做太多任务，将这些任务交由子线程去做，就算子线程 `panic` 也不会导致整个程序的结束

当没有错误发生时，函数返回一个用 `Result` 类型包裹的值 `Ok(T)`，当错误时，返回一个 `Err(E)`
对于 `Result` 返回我们有很多处理方法，最简单粗暴的就是 `unwrap` 和 `expect`，这两个函数非常类似
```
use std::net::IpAddr;
let home: IpAddr = "127.0.0.1".parse().unwrap();
```
上面的 `parse` 方法试图将字符串 `"127.0.0.1"` 解析为一个 IP 地址类型 `IpAddr`，它返回一个 `Result<IpAddr, E>` 类型，如果解析成功，则把 `Ok(IpAddr)` 中的值赋给 `home`，如果失败，则不处理 `Err(E)`，而是直接 `panic`
	就是说，`parse` 返回的是左侧变量所对应的类型的 `Result` 类型，还需要用 `unwrap` 从 `Result` 中提取出对应的类型
***因此 `unwrap` 简而言之：成功则返回值，失败则 `panic`，总之不进行任何错误处理。***

当我们的代码注定是正确时，你可以用 `unwrap` 等方法直接进行处理，反正也不可能 `panic`
如果该字符串是来自于用户输入，那在实际项目中，就必须用错误处理的方式，而不是 `unwrap`

每个用户都通过 websocket 连接到该服务器来接收和发送消息，该过程就涉及到 socket 文件的读写，那么此时，如果一个用户的读写发生了错误，显然不能直接 `panic`，否则服务器会直接崩溃，所有用户都会断开连接

其实 `?` 就是一个宏，它的作用跟上面的 `match` 几乎一模一样

而智能指针则不然，它虽然也号称指针，但是它是一个复杂的家伙：通过比引用更复杂的数据结构，包含比引用更多的信息，例如元数据，当前长度，最大可用长度等，可以提供比引用更多的功能特性
`Box<T>` 允许你将一个值分配到堆上，然后在栈上保留一个智能指针指向堆上的数据

`a` 是 `String` 类型，它其实是一个智能指针结构体，该智能指针存储在函数栈中，指向堆上的字符串数据。当被从 `foo` 函数转移给 `main` 中的 `b` 变量时，栈上的智能指针被复制一份赋予给 `b`，而底层数据无需发生改变，这样就完成了所有权从 `foo` 函数内部到 `b` 的转移
	就是说数据是存储在堆上的没有改变，改变的是指向同一份数据的指针的改变，在栈上发生改变

创建一个智能指针指向了存储在堆上的 `3`，并且 `a` 持有了该指针
- `println!` 可以正常打印出 `a` 的值，是因为它隐式地调用了 `Deref` 对智能指针 `a` 进行了解引用
- - 最后一行代码 `let b = a + 1` 报错，是因为在表达式中，我们无法自动隐式地执行 `Deref` 解引用操作，你需要使用 `*` 操作符 `let b = *a + 1`，来显式的进行解引用

***当栈上数据转移所有权时，实际上是把数据拷贝了一份，最终新旧变量各自拥有不同的数据，因此所有权并未转移***
***而堆上则不然，底层数据并不会被拷贝，转移所有权仅仅是复制一份栈中的指针，再将新的指针赋予新的变量，然后让拥有旧指针的变量失效，最终完成了所有权的转移***

使用 `Option<T>`，是为了从 `Some` 中取出其内部的 `T` 值以及处理没有值的情况

`ptr: *mut Foo` 是指向 foo 的普通指针，而 `let mut ret: Box<Foo>` 就是其智能指针
使用 `Box::from_raw(ptr)` 将原始指针转换为 `Box<Foo>`。这是安全的，因为我们确保了 `ptr` 指向的是一个拥有所有权的 `Foo` 实例
然后，我们检查 `b` 字段是否已经是一个 `Some` 值。如果不是，我们将其设置为 `Some("hello".to_owned())`。这是必要的，因为测试期望 `b` 字段是 `Some("hello")`
`       let data = Box::new(Foo { a: 1, b: None });`
这个是在堆上建立了一个 Foo 对象，然后让 data 作为智能指针去指向它
	此时注意结构体的b是None
`let ptr_1 = &data.a as *const u128 as usize;` 这个就是引用 data. A 属性，又建了个普通指针
在 Rust 编程语言中，`.to_owned()` 方法是一个通用的方法，它用于创建一个值的所有权副本
创建一个值的独立所有权副本，这样你就可以在不同的上下文中使用这个值而不会影响原来的值
Box当中就是有 `Box::into_raw(data)` 与 ` Box::from_raw(ptr)` 方法, into_raw 是将智能指针转化为普通指针，而 from_raw 就是将普通指针 ptr 转为智能指针

`ref mut foo `
	`ref` 关键字表示我们想要获取原始引用，而不是值的副本
	`mut` 关键字表示这个引用是可变的，我们可以更改引用指向的值

生命周期，简而言之就是引用的有效作用域
主要作用是避免悬垂引用，它会导致程序引用了本不该引用的数据

- `r` 引用了内部花括号中的 `x` 变量，但是 `x` 会在内部花括号 `}` 处被释放，因此回到外部花括号后，`r` 会引用一个无效的 `x`
- 此处 `r` 就是一个悬垂指针，它引用了提前被释放的变量 `x`
如果想要编译通过，也很简单，只要 `'b` 比 `'a` 大就好。总之，`x` 变量只要比 `r` 活得久，那么 `r` 就能随意引用 `x` 且不会存在危险
- 和泛型一样，使用生命周期参数，需要先声明 `<'a>`
- 因此 `longest` 函数并不知道 `x` 和 `y` 具体会活多久，只要知道它们的作用域至少能持续 `'a` 这么长就行

`result` 在函数结束后就被释放，但是在函数结束后，对 `result` 的引用依然在继续
	最好的办法就是返回内部字符串的所有权，然后把字符串的所有权转移给调用者
**结构体 `ImportantExcerpt` 所引用的字符串 `str` 必须比该结构体活得更久**

数组实现了 `IntoIterator` 特征，Rust 通过 `for` 语法糖，自动把实现了该特征的数组类型转换为迭代器（你也可以为自己的集合类型实现此特征），最终让我们可以直接对一个数组进行迭代

**迭代器之所以成为迭代器，就是因为实现了 `Iterator` 特征**，要实现该特征，最主要的就是实现其中的 `next` 方法，该方法控制如何从集合中取值，最终返回值的类型是[关联类型](https://course.rs/basic/trait/advance-trait#%E5%85%B3%E8%81%94%E7%B1%BB%E5%9E%8B) `Item`
Rust 闭包在形式上借鉴了 `Smalltalk` 和 `Ruby` 语言，与函数最大的不同就是它的参数是通过 `|parm1|` 的形式进行声明，如果是多个参数就 `|param1, param2,...|`，下面给出闭包的形式定义：
```
|param1, param2,...| {
    语句1;
    语句2;
    返回表达式
}

```
如果只有一个返回表达式的话，定义可以简化为：`|param1| 返回表达式
`